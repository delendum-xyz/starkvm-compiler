// basic block compiler
// Translate basic block to MidenVM

struct atom_t {
  // any valid miden assembler is allowed here
  // provided it is balanced syntactically
  masm: list[string];
}
instance Str[atom_t] { fun str (x:atom_t) : string => cat "\n  " x.masm; }

ctor atom_t (x:string) => atom_t ( list[string] x );

struct label_t {
  name: string;
}
instance Str[label_t] { fun str (x:label_t) => x.name; }

struct switch_t {
  targets: list[label_t];
}
instance Str[switch_t] { 
  fun str (x:switch_t) => 
    cat "," (map str of label_t x.targets)
  ;
}

val phalt = Switch$ switch_t Empty[label_t];

// unconditional goto
fun ugoto (x:string) : terminator_t  => Switch (switch_t ([x.label_t]));

// conditional goto (false case first)
fun cgoto (x:string) (y:string) : terminator_t  => Switch (switch_t ([x.label_t,y.label_t]));

struct call_t {
  target: label_t;
}
instance Str[call_t] { fun str (x: call_t) => x.target.str; }

struct tailcall_t {
  target: label_t;
}
instance Str[tailcall_t] { fun str (x: tailcall_t) => x.target.str; }

struct return_t {}

variant terminator_t = 
| Switch of switch_t
| Call of call_t
| TailCall of  tailcall_t
| Return of return_t
; 
instance Str[terminator_t] { 
  fun str : terminator_t -> string =
  | Switch x => "Switch " + x.str
  | Call x => "Call " + x.str
  | TailCall x => "TailCall " + x.str
  | Return x => "Return"
  ;
}

struct block_t {
  label: label_t;           // Symbolic entry point
  atoms: list[atom_t];     // sequentially exected codes 
  term: terminator_t;
}
instance Str[block_t] {
  fun str (x: block_t) =>
    x.label.str + ":\n  " +
    cat "\n  " (map str of atom_t x.atoms) +"\n  " +
    x.term.str
  ;
}

struct program_t {
  proot: label_t;
  blocks: list[block_t];
}
instance Str[program_t] { 
  fun str (x:program_t) => 
    "PROGRAM " + x.proot.str + "\n" +
    cat "\n" (map str of block_t x.blocks)
  ; 
}

typedef label_map_t = strdict[int];

fun make_label_map (p:program_t) : label_map_t {
  var d = strdict[int] ();
  var counter = 1;
  for block in p.blocks do
    if block.label.name in d do
      println$ "ERROR DUPLICATE LABEL " + block.label.name;
      System::exit(1);
    done
    d.add block.label.name counter;
    ++counter;
  done
  return d; 
}
/*
proc valida-et
proc validate_block (block:block_t) (d:label_map_t) {
  if not block.name.name in d do
    println$ "ERROR, block label " + block.label + " undefined????";
    System::exit(1);
  done 
  validate_terminator block.term d;
}

proc validate_program (p:program_t) (d:label_map_t) {
  if not p.proot.name in d do
    println$ "ERROR, program root " + p.proot + " undefined";
    System::exit(1);
  done 
  for block in p.blocks perform validate_block block d; 
}
*/ 
// -----------------------------------------------------
// Sample program
var b1 = block_t (
  "start".label_t, 
  list ( 
    atom_t ( list ("swap","dup") ), 
    atom_t ( list ("drop", "u32wrapping_add") )
   ), // start
   Switch (switch_t (([label_t ("L1")]))) // unconditional goto
 )
;

var b2 = block_t (
  label_t ("L1"), 
  list ( 
    atom_t ( list ("swap","dup") ), 
    atom_t ( list ("drop", "u32wrapping_add") )
  ),
  Switch (switch_t (Empty[label_t])) // HALT 
);

// sample program
var ap = 
  program_t (
    label_t ("start"),
    list (b1, b2)
  )  // program 
;

println$ ap.str;

// -----------------------------------------------------
// FIBONACCI: from fib.masm

var startup = 
"""
                                     # let mut a = 1                           :   2
  push.1                             # 1                                       :   2
  loc_store.0                        # init a                                  :   2
                                     # let mut b = 1                           :   3
  push.1                             # 1                                       :   3
  loc_store.1                        # init b                                  :   3
                                     # let mut n = 10                          :   4
  push.10                            # 10                                      :   4
  loc_store.2                        # init n                                  :   4
                                     # let mut tmp = 0                         :   5
"""
;

var block1 = block_t (
  "fibstart".label_t, 
  ([atom_t startup]),
  ugoto "L1" )            // unconditional jump to L1
;

var fbody = 
"""
      loc_load.0                   # <-a                                     :   8
      loc_store.3                  # tmp<-                                   :   8
                                   # a = a + b                               :   9
      loc_load.0                   # <-a                                     :   9
      loc_load.1                   # <-b                                     :   9
      u32checked_add               # +                                       :   9
      loc_store.0                  # a<-                                     :   9
                                   # b = tmp                                 :  10
      loc_load.3                   # <-tmp                                   :  10
      loc_store.1                  # b<-                                     :  10
                                   # n = n -1                                :  11
      loc_load.2                   # <-n                                     :  11
      push.1                       # 1                                       :  11
      u32checked_sub               # -                                       :  11
      loc_store.2                  # n<-                                     :  11
      loc_load.2                   # <-n                                     :  12
      push.0                       # 0                                       :  12
      u32checked_gt                # >  
"""
;
var block2 = block_t (
  "L1".label_t, 
  ([atom_t fbody]),
  cgoto "L2" "L1" // if n > 0 goto L1 else L2
  )
;

var endoff =
"""
                                   # SWITCH EXIT                             :  15
                                   # eval a                                  :  16
loc_load.0                         # <-a                                     :  16
                                   # eval b                                  :  17
loc_load.1                         # <-b                                     :  17
""";

var block3 = block_t (
  "L2".label_t, 
  ([atom_t endoff]),
  phalt 
  )
;


var fib = program_t (
  "finstart".label_t, 
  ([
    block1, 
    block2,
    block3
  ])
);

println$ fib.str;

var lm = make_label_map fib;
println$ "Program label map " + lm.str;
