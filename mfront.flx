include "std/control/chips";
include "./mfront/lib/mfront_lexer";
include "./mfront/lib/mfront_symtab";
include "./mfront/lib/mfront_expr";
include "./mfront/lib/miden_opcodes";

chip loader(filename: string, fail:string->0) 
  connector io
    pin out : %> string
{
  var f = load(filename);
  if f == "" perform 
    throw_continuation { fail$ "Missing input file " + filename; };
  var lines = split(f,char "\n");
  for line in lines do
    write (io.out, line);
  done
}

chip line_counter (counter: &int)  
  connector io
    pin inp: %<string
    pin out: %>string
{
  while true do
   var line = read io.inp;
   post_incr counter;
   write (io.out, line);
  done
}

chip comment_stripper
  connector io
    pin inp: %< string
    pin out: %> string
{
  while true do
    var s = read(io.inp);
    for (var i=0; i< s.len.int; ++i;) 
      if s.[i] == char "#" goto endline;
  endline:>
    write (io.out, s.[0 .. i - 1]);
  done
}

// Error handling chip.
chip ehandler  
  connector io
    pin inp : %< string
{
  var e = read io.inp;
  println$ "[ehandler]: " + e;
  System::exit(1);
}

// ISSUE: what should nested switches do??
//
// My brain is saying a SWITCH introduces a scope
// so actually it is like a C block { ... }
//
// This means it has local variables, and it means
// from inside a SWITCH we can jump locally to any label
// inside the switch, OR to any label in an ancestor.
// But you cannot jump from outside to inside.
//
// The semantics at the moment don't support nesting
// because "SWITCH" sets the global PC to 1.
//
// There are two choices: using a global PC and a stack for
// local variables matches how C's von Neumann machine works.
// This means the labels in a nested switch must be distinct
// from the ones in an enclosing switch, so that labels
// are globally unique (well, at least within a procedure).
//
// OTOH, if we use a separate PC for a nested switch,
// we CANNOT jump to an arbitrary external label 
// we are FORCED to exit the switch by "falling through"
//
// This makes the SWITCH behave more like a "basic block":
// ONE entry point and ONE exit only.
//
// In fact, this can 


class stmt_parser {
  fun isinteger(x:string) {
    for ch in x 
      if not isdigit ch return false;
    return true;
  }
    
  proc checkint (fail: string->0) (x:string) {
    if not isinteger(x) perform
      fail("GOTO target must be integer, got " + x);
  }

  variant ifparity_t = 
    | ifblock of int
    | elseblock of int
    | whileblock
  ;

  chip stmt (fail:string -> void)
    connector io
      pin inp : %< string
      pin out : %> string
  {
    open symbol;
    proc pr(s:string) { write (io.out, s); }
    proc prln(s:string) { write (io.out, s + "\n"); }

    var counter = 0;
    var ifelsestack = Empty[ifparity_t];
    var label_counter = 1; // the first user label must be 1
    var max_lab = (0,0); // error tracking: label index, line used

    // SWITCH nesting depth control
    var pc_address = 1000;
    var sp_address = 1001;
    var sp_base = 4000;

    var switch_depth = 0;

    var h: string;
    var t: lexer::toks_t;
    proc advance() {
      match t with 
      | Cons(h1,t1) => h=h1; t = t1; 
      | _ => h = "";
      endmatch;
    }
    fun lookahead () =>
      match t with 
      | Cons(h1,t1) => h1
      | _ => ""
    ;

    var symtab = symbol_table_t(0, strdict[syminfo_t]());

    var switch_counter = 1;
    var next_instr_must_be_label = false;

    while true do
      ++counter;
      var line = read(io.inp);
      //prln$ counter.str + ": " + line;
      var tokens = lexer::lex fail line;
      match tokens with
      | Cons (head, tail) => 
        h = head;
        t = tail;

        // check if last instruction was CALL
        if h != "LABEL" and next_instr_must_be_label do 
          fail("Next instruction after CALL must be LABEL");
        else
          next_instr_must_be_label = false;
        done
         
        if h == "SWITCH" do
          if switch_depth > 0 perform fail("Nested switch not supported");
          ++switch_depth; 
          prln$ "push.0 # begin switch  with PC = 0";
          prln$ "mem_store."+ pc_address.str + " # PC";
          prln$ "push.1 # make loop start";
          prln$ "while.true # begin the SWITCH";
          prln$ "mem_load."+pc_address.str + " # load PC";
          prln$ "u32wrapping_add.1      # increment by 1";
          prln$ "dup                   # keep on top of stack for comparisons";
          prln$ "mem_store."+pc_address.str + " # save PC";
          prln$ "u32checked_eq."+h+ " # check if PC is forcase 1";
          prln$ "if.true # start code for this case";

        elif h in ("GOTO", "TAILCALL") do
          advance;
          checkint fail h; // check the next token is an integer
          var labval = int h;
          if labval > max_lab.0 perform
            max_lab = labval, counter;
          prln$ "# GOTO " + h;
          prln$ "push."+(h.int - 1).str +" # jump address minus 1"; 
          prln$ "mem_store." + pc_address.str + " # set PC to " + h;
          prln$ "# -------";

        elif h == "LABEL" do
          advance;
          checkint fail h; // check the next token is an integer
          labval = int h - 1;  // allow for increment in loop head 
          if labval != label_counter 
            perform fail ("Invalid label counter " + h ", should be " + (label_counter - 1).str);
          ++label_counter; 
          prln$ "# LABEL " + h;
          prln$ "else # end case " + (switch_counter - 1).str;
          prln$ "u32checked_eq."+h+ " # check if PC is for this case";
          prln$ "if.true # start code for this case";
          ++switch_counter; // count the number of 'end' we need at the switch end
        elif h == "BREAK" do
          prln$ "push.0xFFFFFFFF # BREAK";
          prln$ "mem_store."+pc_address.str + "# ->PC";

        elif h == "ENDSWITCH" do
          if switch_depth == 0 perform fail "End switch outside switch";
          --switch_depth;

          if max_lab.0 > switch_counter perform
            fail("Jump to non existent label " + max_lab.0.str + " line " + max_lab.1.str);
          var end_case = switch_counter;
          while switch_counter > 0 do
            prln$ "end # switch case "+switch_counter.str;
            --switch_counter;
          done
          // termination is now PC >= end case
          // catches break too because it's now 0xFFFF_FFFF
          prln$ "mem_load."+pc_address.str + " #load PC";
          prln$ "push." + end_case.str;
          prln$ "u32unchecked_lte"; 
          prln$ "end #while loop";
          prln$ "# SWITCH EXIT";

        elif h=="CALL" do
          advance;
          checkint fail h;
          var target = h.int;
          next_instr_must_be_label = true;
          prln$ "mem_load."+pc_address.str+ " # get PC";
          prln$ "mem_load."+sp_address.str+ " # get SP";
          prln$ "u32wrapping_sub.1       # SP--";
          prln$ "dup";
          prln$ "mem_store."+sp_address.str+" # save SP";
          prln$ "mem_store                 # store PC at SP";
          prln$ "push."+(target - 1).str +" # CALL target - 1";
          prln$ "mem_store."+pc_address.str+" # set PC to target - 1";

        elif h=="RETURN" do
          // NOTE: the return address is that of the block containing
          // the original call instruction, but the loop head will
          // increment it to the next block allowing the caller to continue
          // after the call instruction
          prln$ "mem_load."+sp_address.str+ " # get SP";
          prln$ "dup";
          prln$ "u32wrapping_add.1 # pop stack";
          prln$ "mem_store."+sp_address+" # save SP"; 
          prln$ "mem_load # get return address";
          prln$ "mem_store."+pc_address.str+" # set PC";

        // eval
        elif h == "eval" do
          var e,rest = expr_parser::parse_expr fail t;
          prln$ "# " + line;
          //prln$ "# eval[parsed] "  e.str;
          pr$ expr_emit::postfix fail &symtab e;

        // let
        elif h == "let" do
          prln$  "# " + line;
          advance;
          var mut = false;
          if h == "mut" do
            mut = true;
            advance;
          done
          var name = h; // check it's an identifier!
          advance;
          if h != "=" do
            fail("Variable decl requires = symbol");
          done
          add fail &symtab name mut "u32";
          //prln$ "# Added variable '" + name +"' to symbol table";
          var e2,rest2 = expr_parser::parse_expr fail t;
          //prln$ "# eval[inp] " + cat " " tokens;
          //prln$ "# eval[parsed] " +  e2.str;
          pr$ expr_emit::postfix fail &symtab e2 ;
          prln$ "pop.local." + get_address fail &symtab name +"# init " + name;

          // assignment (requires "assign" binder)

        elif #lookahead == "=" do
          prln$ " # " + line;
          name = h;
          advance;
          e,rest = expr_parser::parse_expr fail t;
          pr$ expr_emit::postfix fail &symtab e ;
          var sym = get_info fail &symtab name;
          if not sym.mut do
            fail("Write to immutable variable " + name);
          done
          prln$ "pop.local." + sym.loc.str + "# " + name + "<-";

        elif h == "while" do
          chainmatch t with
          | [".","true"] => 
            prln$ "while.true # Miden"; // miden while.true
          ormatch unbox t.rev with
          | Cons ("{", tail) => 
            t = tail.rev;
            // evaluate condition
            e,rest = expr_parser::parse_expr fail t;
            pr$ expr_emit::postfix fail &symtab e ;
            prln("while.true # Rust while");
            ifelsestack = Cons(whileblock,ifelsestack);
          | _ => fail ("while requires trailing {");
          endmatch;
        

  /* NOTE on if/else stuff

     There is a problem maintaining the state as follows:

     In the "Rust" input we have the syntax

     } else if expr {

    which leaves the input in "if" mode, which can be
    terminated by a single "}", a "} else {" or another "} else if expr {"

    The action is to pop, swap from "if" to "else" of do nothing, respectively
    So } else if { allows chaining tests like "elif" would.

    However the output syntax has no elif equivalent. So we have to do
    an else, start a new block, evaluate the condition, and then do an if.true.

    So a chain "walks to the right" indentwise with every elif chain step.
    When we finally get a plain else, and it is terminated, we have tgo
    dedent to line up with the opening "if" and emit enough "end" to do that.

    So the stack entry for "if" needs a count >= 1 to keep track of how
    many "end" have to be emitted and, the count needs to be transfered
    to the else constuctor too, when the if is terminated by an else.
    An "elif" just increments the count.
  */
        // begin an Rust if block
        elif h == "if" do
          chainmatch t with
          | [".","true"] => 
            prln$ "if.true # Miden"; // miden if.true
          ormatch unbox t.rev with
          | Cons ("{", tail) => 
            t = tail.rev;
            // evaluate condition
            e,rest = expr_parser::parse_expr fail t;
            pr$ expr_emit::postfix fail &symtab e ;
            prln("if.true # Rust if");
            ifelsestack = Cons(ifblock 1,ifelsestack);
          | _ => fail ("if requires trailing {");
          endmatch;
        // end an if or else block and maybe start a new if
        elif h == "}" do
          advance;
          match h with
          | "" => // terminate ifelse block
            match ifelsestack with
            | Empty => fail("Unmatched }");
            | Cons(ifblock n,stk) =>
              ifelsestack = stk; // terminate ifelse block (no matching else)
              var nest = n; 
              while nest > 0 do
                prln$ "end # Rust endif";
                --nest;
              done 
            | Cons(elseblock n,stk) =>
              ifelsestack = stk; // terminate ifelse block else
              nest = n;
              while nest > 0 do
                prln$ "end # Rust endif";
                --nest;
              done 
            | Cons(whileblock,stk) =>
              ifelsestack = stk; // terminate while block (no matching else)
              prln$ "end # Rust endwhile";
            endmatch;

          | "else" => // switch nearest enclosing if to else
            advance;
            match h with
            | "{" => // final else block
              match ifelsestack with
              | Empty => fail("Unmatched else ");
              | Cons(elseblock n,stk) => fail("Unmatched else");
              | Cons(ifblock n,stk) =>
                ifelsestack = Cons (elseblock n, stk);
                prln$ "else # Rust else";
              endmatch;
   
            | "if" => // chained if
              match ifelsestack with
              | Empty => fail("Unmatched else ");
              | Cons(elseblock n,stk) => fail("Unmatched else if");
              | Cons(ifblock n,stk) =>
                ifelsestack = Cons (ifblock (n+1), stk);
                prln$ "else # Rust else if";
                // evaluate condition
                e,rest = expr_parser::parse_expr fail t;
                pr$ expr_emit::postfix fail &symtab e ;
                prln("if.true # Rust else if");
              endmatch; // ifelse
            endmatch; // else 
          endmatch; // leading } symbol
        elif h == "else" do
          prln$ "else # Miden";
        elif h == "end" do
          prln$ "end # Miden";
        elif h == "push" do
          // up to 16 elements allowed
          var pushcode = cat "" tokens;
          if MidenOpcodes::isvalidpush pushcode do
            prln$ pushcode + " # validated";
          else 
            prln$ pushcode + " # INVALID PUSH";
          done
        else
          var rtoks = unbox tokens.rev;
          match rtoks with
          | Cons (h,t) =>
            if isinteger(h) do
              rtoks = Cons("$",t);
            done
          | _ => ;
          endmatch;
//println$ "opkey: '" + opkey+"'";
          var opk = cat "" tokens;
          var opkey = cat "" rtoks.rev.unbox;
          if opkey.MidenOpcodes::isopcode do 
            prln$ opk + " # validated opcode";
          else
            prln$ opk + " # OPCODE NOT VALIDATED";
          done
        done // leading token chain check

      | _ => ;
       
      endmatch;
    done
  }
}

// NOTE: tabs comments to column 35
chip printer  (line_count: &<int)
  connector io
    pin inp : %< string
{
  fun align_comments(line:string):string {
    match find(line, char "#") with
    | None => var out = line;
    | Some k =>
      var l = line.[to k];
      var r = line.[k + 1 to];
      if l.len.int > 32 do
        l= l+ " ";
      else
        l = (l.rstrip + " " * 35).[0 to 35];
      done
      if r.len.int > 0 do
        var outcmt = (r.strip + " " *40).[to 40];
        out = l + "# " + outcmt + f":%4d" (*line_count);
      else
        out = l;
      done
    endmatch;
    return out;
  }

  var x = "";
  var indent = 0;

  while true do
    var s = read io.inp;
    x += s;
    var xs = split(x,"\n");
    var n = xs.len.int - 1;
    for(var i = 0; i<n; ++i;) do
      var line = head xs;
      xs = tail xs;
      if startswith line "end" or startswith line "else" perform --indent;
      var indented_line = "  " * indent + line;
      var outline = align_comments indented_line;
      if startswith line "while.true" or startswith line "if.true" or startswith line "else" perform ++indent; 
      println$ outline;
    done
    x = head xs;
  done
}


proc run(filename:string) {
  var line_count = 0;
  var ein,eout = mk_ioschannel_pair[string]();
  proc ewriter (e: string) {
    while true do
      write (eout, "fail["+ line_count.str + "]: " + e); 
    done
  }
  proc failproc (e:string) { throw_continuation { ewriter e; }; };

  device source = loader (filename, failproc);
  device stmt = stmt_parser::stmt failproc;
  device counter = line_counter &line_count;
  device printout = printer &line_count;
  circuit 
    connect source.out, counter.inp
    connect counter.out, comment_stripper.inp
    connect comment_stripper.out, stmt.inp
    connect stmt.out, printout.inp
    wire ein to ehandler.inp
  endcircuit
}

run(System::argv 1);
