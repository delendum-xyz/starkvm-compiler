class MidenOpcodes {

  // A field element is 64 bits, a machine word is 256 bits = 4 field elements
  // u32 is 32 bits = 4 bytes = 8 hex digits
  // field element is 16 hex digits
  // machine word is 64 hex digits
  //
  //  ordinary swaps and move things are MISCODED
  //  as 0 pop 0 push ... should really be 16,16
  //  similarly dup.n which is really n, n + 1
  //  and adv_push.$
  //  These will need special handing in the emulator


  //  OPCODE                cycles, pop, push
  //  codes with .$ at the end accept an integer literal

  var opcodes = 
    ("assert"                 ,1,1,0),
    ("assertz"                ,2,1,0),
    ("assert_eq"              ,2,2,0),

    ("add"                    ,1,2,1),
    ("add.$"                  ,2,1,1),
    ("sub"                    ,2,2,1),
    ("sub.$"                  ,2,1,1),
    ("mul"                    ,1,2,1),
    ("mul.$"                  ,2,1,1),
    ("div"                    ,2,2,1),
    ("div.$"                  ,2,1,1),
    ("neg"                    ,1,1,1),
    ("inv"                    ,1,1,1),
    ("pow2"                   ,16,1,1),
    ("exp"                    ,73,2,1),
    ("exp.$"                  ,73,1,1),
    ("not"                    ,1,1,1),
    ("and"                    ,1,2,1),
    ("or"                     ,1,2,1),
    ("xor"                    ,7,2,1),
    ("eq"                     ,1,2,1),
    ("eq.$"                   ,2,1,1),
    ("neq"                    ,1,2,1),
    ("neq.$"                  ,2,1,1),
    ("lt"                     ,17,2,1),
    ("lte"                    ,18,2,1),
    ("gt"                     ,18,2,1),
    ("gte"                    ,18,2,1),
    ("eqw"                    ,15,8,4),

    ("u32test"                 ,5,1,2),               
    ("u32testw"                ,23,4,5),
    ("u32assert"               ,3,1,1),
    ("u32assert.1"             ,3,1,1),
    ("u32assert.2"             ,1,2,2),
    ("u32assertw"              ,6,4,4),
    ("u32cast"                 ,2,1,1),
    ("u32split"                ,1,1,2),

    ("u32checked_add"          ,4,2,1),
    ("u32checked_add.$"        ,6,1,1),
    ("u32overflowing_add"      ,1,2,2),
    ("u32overflowing_add.$"    ,3,1,2),
    ("u32wrapping_add"         ,2,2,1),
    ("u32wrapping_add.$"       ,4,1,1),
    ("u32overflowing_add3"     ,1,3,2),
    ("u32wrapping_add3.$"      ,2,3,1),

    ("u32checked_sub"          ,4,2,1),
    ("u32checked_sub.$"        ,6,1,1),
    ("u32overflowing_sub"      ,1,2,2),
    ("u32overflowing_sub.$"    ,2,1,2),
    ("u32wrapping_sub"         ,2,2,1),
    ("u32wrapping_sub.$"       ,4,1,1),

    ("u32checked_mul"          ,4,2,1),
    ("u32checked_mul.$"        ,6,1,1),
    ("u32overflowing_mul"      ,1,2,2),
    ("u32overflowing_mul.$"    ,3,1,2),
    ("u32wrapping_mul"         ,2,2,1),
    ("u32wrapping_mul.$"       ,4,1,1),
    ("u32overflowing_madd"     ,1,3,2),
    ("u32wrapping_madd.$"      ,2,3,1),

    ("u32checked_div"          ,3,2,1),
    ("u32checked_div.$"        ,5,1,1),
    ("u32unchecked_div"        ,2,2,1),
    ("u32unchecked_div.$"      ,4,1,1),

    ("u32checked_mod"          ,4,2,1),
    ("u32checked_mod.$"        ,6,1,1),
    ("u32unchecked_mod"        ,3,2,1),
    ("u32unchecked_mod.$"      ,5,1,1),

    ("u32checked_divmod"       ,2,2,2),
    ("u32checked_divmod.$"     ,4,1,2),
    ("u32unchecked_divmod"     ,1,2,2), 
    ("u32unchecked_divmod.$"   ,3,1,2),

    ("u32checked_and"          ,1,2,1),
    ("u32checked_or"           ,6,2,1),
    ("u32checked_xor"          ,1,2,1),
    ("u32checked_not"          ,5,1,1),

    ("u32checked_shl"          ,47,2,1),
    ("u32checked_shl.$"        ,4,1,1),
    ("u32unchecked_shl"        ,40,2,1),
    ("u32unchecked_shl.$"      ,3,1,1),

    ("u32checked_shr"          ,47,2,1),
    ("u32checked_shr.$"        ,4,1,1),
    ("u32unchecked_shr"        ,47,2,1),
    ("u32unchecked_shr.$"      ,4,1,1),

    ("u32checked_rotl"         ,47,2,1),
    ("u32checked_rotl.$"       ,4,1,1),
    ("u32unchecked_rotl"       ,40,2,1),
    ("u32unchecked_rotl.$"     ,3,1,1),

    ("u32checked_rotr"         ,59,2,1),
    ("u32checked_rotr.$"       ,6,1,1),
    ("u32unchecked_rotr"       ,44,2,1),
    ("u32unchecked_rotr.$"     ,3,1,1),
 
    ("u32checked_eq"           ,2,2,1),
    ("u32checked_eq.$"         ,4,1,1),
    ("u32checked_neq"          ,3,2,1),
    ("u32checked_neq.$"        ,5,1,1),

    ("u32checked_lt"           ,6,2,1),
    ("u32unchecked_lt"         ,5,2,1),
    ("u32checked_lte"          ,8,2,1),
    ("u32unchecked_lte"        ,7,2,1),
    ("u32checked_gt"           ,7,2,1),
    ("u32unchecked_gt"         ,6,2,1),
    ("u32checked_gte"          ,7,2,1),
    ("u32unchecked_gte"        ,6,2,1),

    ("u32checked_min"          ,9,2,1),
    ("u32unchecked_min"        ,8,2,1),
    ("u32checked_max"          ,10,2,1),
    ("u32unchecked_max"        ,9,2,1),

    ("drop"                    ,1,1,0),
    ("dropw"                   ,4,4,0),
    ("padw"                    ,4,0,4),
    ("dup"                     ,1,0,1),
    ("dup.$"                   ,3,0,1),
    ("dupw"                    ,4,0,4),
    ("dupw.$"                  ,4,0,4),
    ("swap"                    ,6,0,0),
    ("swap.$"                  ,6,0,0),
    ("swapw.$"                 ,1,0,0),
    ("movup.$"                 ,4,0,0),
    ("movupw.$"                ,3,0,0),
    ("movdn.$"                 ,4,0,0),
    ("movdnw.$"                ,3,1,0),

    ("cswap"                   ,1,1,0),
    ("cswapw"                  ,1,1,0),

    ("sdepth"                  ,2,0,1),
    ("caller"                  ,1,0,1),
    ("locaddr.$"               ,2,0,1),

    ("adv_loadw"               ,1,0,4),
    ("adv_pipe"                ,2,13,13),

    ("mem_load"                ,1,1,1),
    ("mem_load.$"              ,2,0,1),
    ("mem_loadw"               ,1,5,4),
    ("mem_loadw.$"             ,2,4,4),

    ("mem_store"               ,2,2,0),
    ("mem_store.$"             ,4,1,0),
    ("mem_storew"              ,1,5,0),
    ("mem_storew.$"            ,3,4,0),
    ("mem_stream"              ,2,13,13),

    ("loc_load.$"              ,4,0,1),
    ("loc_loadw.$"             ,4,0,4),
    ("loc_store.$"             ,5,1,0),
    ("loc_storew.$"            ,4,4,4),

    ("rpperm"                  ,1,12,12),
    ("rphash"                  ,16,8,4),
    ("mtree_get"               ,9,6,4),
    ("mtree_set"               ,14,10,8),
    ("mtree_cwm"               ,12,10,12)
  ;

  // check for integer literals miden allows WITHOUT any bounds checks
  fun isdecintlit(x:string) => x in RE2 "\\d+";
  fun ishexintlit(x:string) => x in RE2 "0x[[:xdigit:]]+";
  fun isintlit(x:string) => x.ishexintlit or x.isdecintlit;

  // check for a miden name
  fun isname(x:string) => x in RE2 "\\w+"; 
  fun isqualifiedname(x:string) => x in RE2 "\\w+(::\\w+)*"; 

  fun isopcode(x:string) {
    for v in opcodes 
      if v.0 == x return true;
    return false;
  }

  fun isvalidpush (x:string) {
    return x in RE2 "push(\\.(\\d+|0x[[:xdigit:]]+)){1,16}";
  }

  // cdrop consumes either 1 element or 2 depending on the TOS
  // cdropw consumes either 1 element or 5 depending on the TOS
  fun iscdrop(x:string) {
    return x in ("cdrop", "cdropw");
  }

  fun isctrl(x:string) {
    return x in ("if.true", "while.true", "else", "end", "begin");
  }

  fun isvalid1op (x:string) =>
    x in ("end","begin","else","cdrop","cdropw") or
    x.isopcode
  ; 

  fun isvalid2op (a:string, b:string) {
    match a,b with
    | "if", "true" => return true;
    | "while", "true" => return true;
    | "repeat", x => return x.isintlit;
    | "exec", x => return x.isqualifiedname;
    | "call", x => return x.isqualifiedname;
    | "syscall", x => return x.isqualifiedname;
    | "proc", x => return x.isname;
    | op,arg =>
      return arg.isintlit and (op+".$").isopcode;
    endmatch;
  }

  fun isvalid3op (a:string, b:string,c:string) {
    match a,b,c with
    | "proc", name,nlocals => return name.isname and nlocals.isintlit;
    | _ => return false;
    endmatch;
  }

 
  fun isvalidopcode (tokens: list[string]) {
    // get rid of the deviant push opcode
    if (cat "" tokens).isvalidpush return true;

    // all other ops have 1,2,or 3 parts separated by "."
    match tokens with
    | ([op]) => return isvalid1op(op);
    | ([op,d,a]) =>
       if d == "." do
         return isvalid2op(op,a);
       else 
         return false;
       done
    | ([op,d1,a,d2,b]) =>
       if d1 == "." and d2 == "." do
         return isvalid3op(op,a,b);
       else 
         return false;
       done
    | _ => return false;
    endmatch;
  }

// types
typedef MVM_atomic_type_t = (
  | `p // prime field element
  | `w // machine word (4 elements)
  | `u32 // 32 bit wrapping unsigned int: ring
  | `i32 // 32 bit checked or unchecked: integer approx
);

// open form
typedef open_MVM_type_constructor_t [T] = (
  | `sum of list[T]
  | `product of list[T]
  | `procedure of list[T] * list[T] // domain, codomain
  | `address of int                 // memory address
  | `atom of MVM_atomic_type_t 
);

// Closed forms
typedef mvm_type_t = open_MVM_type_constructor_t [mvm_type_t];

// these are really open since they don't depend on the recursion
val void_t = `sum Empty[mvm_type_t];
val unit_t = `product Empty[mvm_type_t];
val bool_t = `sum ([unit_t, unit_t]);
 
// terms
typedef u32_test_t = (
    | `u32test
    | `u32testw
    | `u32assert
    | `u32assert_1
    | `u32assert_2
    | `u32assertw
    | `u32cast
    | `u32split
);

typedef u32_checked_t =  (
    // u32 * u32 -> u32
    | `u32checked_add
    | `u32checked_sub
    | `u32checked_mul
    | `u32checked_div
    | `u32checked_mod

    // u32 * u32 -> u32 * u32
    | `u32checked_divmod

    // u32 * u32 -> u32
    | `u32checked_min
    | `u32checked_max
);
typedef u32_unchecked_t = (
    // u32 * u32 -> u32
    | `u32unchecked_min
    | `u32unchecked_max
    | `u32unchecked_div
    | `u32unchecked_mod

    // u32 * u32 -> u32 * u32
    | `u32unchecked_divmod

);

typedef u32_wrapping_t = (
    | `u32wrapping_add
    | `u32wrapping_sub
    | `u32wrapping_mul
);

// u32 * y32 -> u32 * u32
typedef u32_overflowing_t = (
    | `u32overflowing_add
    | `u32overflowing_sub
    | `u32overflowing_mul
);

// u32 * u32 * u32 -> u32 * u32
typedef u32_threeop_t = (
    | `u32overflowing_add3
    | `u32overflowing_madd
);

typedef u32_bitop_t = (
    | `u32checked_and
    | `u32checked_or
    | `u32checked_xor
    | `u32checked_not

    | `u32checked_shl
    | `u32unchecked_shl

    | `u32checked_shr
    | `u32unchecked_shr

    | `u32checked_rotl
    | `u32unchecked_rotl

    | `u32checked_rotr
    | `u32unchecked_rotr
);

typedef u32_comparison_t = (
    | `u32checked_eq
    | `u32checked_neq

    | `u32checked_lt
    | `u32unchecked_lt
    | `u32checked_lte
    | `u32unchecked_lte
    | `u32checked_gt
    | `u32unchecked_gt
    | `u32checked_gte
    | `u32unchecked_gte
);

typedef u32_base_t = (
  | u32_comparison_t
  | u32_bitop_t
  | u32_threeop_t
  | u32_overflowing_t
  | u32_wrapping_t
  | u32_checked_t
  | u32_unchecked_t
  | u32_test_t
);

typedef fieldop_t = (
    | `assert
    | `assertz
    | `assert_eq

    // p * p -> p
    | `add
    | `sub
    | `mul
    | `div
    // p -> p
    | `neg
    | `inv
    | `pow2
    | `exp

    // 2 -> 2
    | `not

    // 2 * 2 -> 2 
    | `and
    | `or
    | `xor

    // p * p -> 2
    | `eq
    | `neq
    | `lt
    | `lte
    | `gt
    | `gte

    // w * w -> 2
    | `eqw
);


typedef stack_manip_t = (
    | `drop
    | `dropw
    | `padw
    | `dup
    | `dupw
    | `swap

    // generic
    // 2 * f -> f
    // 2 * u32 -> u32
    // 2 * 2 -> 2
    | `cswap
    // 2 * w -> w
    | `cswapw

    | `sdepth
    | `caller

    | `adv_loadw
    | `adv_pipe

    | `mem_load
    | `mem_loadw

    | `mem_store
    | `mem_storew
    | `mem_stream


    | `rpperm
    | `rphash
    | `mtree_get
    | `mtree_set
    | `mtree_cwm
);

// ops with im mode argumemts
typedef imode_t =
(
    | `add
    | `sub
    | `mul
    | `div
    | `exp
    | `eq
    | `neq


    | `u32checked_add
    | `u32overflowing_add
    | `u32wrapping_add
    | `u32wrapping_add3

    | `u32checked_sub
    | `u32overflowing_sub
    | `u32wrapping_sub

    | `u32checked_mul
    | `u32overflowing_mul
    | `u32wrapping_mul
    | `u32wrapping_madd

    | `u32checked_div
    | `u32unchecked_div

    | `u32checked_mod
    | `u32unchecked_mod

    | `u32checked_divmod
    | `u32unchecked_divmod

    | `u32checked_shl
    | `u32unchecked_shl

    | `u32checked_shr
    | `u32unchecked_shr

    | `u32checked_rotl
    | `u32unchecked_rotl

    | `u32checked_rotr
    | `u32unchecked_rotr
 
    | `u32checked_eq
    | `u32checked_neq

    | `dup
    | `dupw
    | `swap
    | `swapw
    | `movup
    | `movupw
    | `movdn
    | `movdnw
    | `locaddr

    | `mem_load
    | `mem_loadw

    | `mem_store
    | `mem_storew

    | `loc_load
    | `loc_loadw
    | `loc_store
    | `loc_storew
);

typedef op_base_t = (
   | fieldop_t
   | u32_base_t
   | stack_manip_t
);

typedef imop_t = (
  | `im of imode_t * int 
  | `push of list[int]
);

typedef op_t = (
  | op_base_t 
  | imop_t
  | `exec of string
  | `call of string
  | `syscall of string
);

typedef block_t = (
  | op_t
  | `seq of list[block_t]
  | `if of block_t
  | `ifelse of block_t * block_t
  | `while of block_t
  | `repeat of int * block_t
);

typedef proc_t = (
  | `proc of string * int * block_t // name, local count, code
);

typedef program_t = (
  | `procs of list[proc_t]
  | `prog of block_t
);

typedef procorexport_t = (
  | `proc of proc_t
  | `export of proc_t
);

typedef library_t = (
  | `procorexport of list[procorexport_t]
);

typedef token_t = string;

// requires valid hex input
fun hexdig (x:char) : int {
  var d = x.ord; 
  val zero = "0".char.ord;
  val nine = "9".char.ord;
  val A = "A".char.ord;
  val F = "F".char.ord;
  val a = "a".char.ord;

  if d <= nine do return d - zero;
  elif a<= F do return d - F;
  else return d - a;
  done
}

fun parse_hex (x:string) : size {
  var v = 0uz;
  var n = x.len.int;
  for (var i=0; i < n; ++i; ) do
    var d = x.i.hexdig.size;
    v = v * 16uz + d;
  done
  return  v;
}

fun parse_dec (x:string) : size {
  var v = 0uz;
  var n = x.len.int;
  for (var i=0; i < n; ++i; ) do
    var d = x.i.hexdig.size;
    v = v * 10uz + d;
  done
  return  v;
}


// parse hex: should be in the library!
fun parse_hex_lit (fail:string->any) (x:string) : size =>
  match x.[0 to 2] with
  | "0x" => parse_hex x.[2 to]
  |  y => fail$ "Invalid hex '" + x + "'"
  endmatch
;
fun parse_dec_lit (fail:string->any) (x:string) : size =>
  parse_dec x
;
fun parse_int_lit (fail:string->any) (x:string) : size =>
  if x.isdecintlit then parse_dec_lit fail x
  elif x.ishexintlit then parse_hex_lit fail x 
  else fail$ "Invalid int literal " + x
  endif
;

fun parse_basic_op (fail:string->any) (op: string) : op_base_t {
  match op with


//----------------------

    | "assert" => return #`assert;
    | "assertz" => return #`assertz;
    | "assert_eq" => return #`assert_eq;

    | "add" => return #`add;
    | "sub" => return #`sub;
    | "mul" => return #`mul;
    | "div" => return #`div;
    | "neg" => return #`neg;
    | "inv" => return #`inv;
    | "pow2" => return #`pow2;
    | "exp" => return #`exp;
    | "not" => return #`not;
    | "and" => return #`and;
    | "or" => return #`or;
    | "xor" => return #`xor;
    | "eq" => return #`eq;
    | "neq" => return #`neq;
    | "lt" => return #`lt;
    | "lte" => return #`lte;
    | "gt" => return #`gt;
    | "gte" => return #`gte;
    | "eqw" => return #`eqw;

    | "u32test" => return #`u32test;               
    | "u32testw" => return #`u32testw;
    | "u32assert" => return #`u32assert;
    | "u32assert.1" => return #`u32assert_1;
    | "u32assert.2" => return #`u32assert_2;
    | "u32assertw" => return #`u32assertw;
    | "u32cast" => return #`u32cast;
    | "u32split" => return #`u32split;

    | "u32checked_add" => return #`u32checked_add;
    | "u32overflowing_add" => return #`u32overflowing_add;
    | "u32wrapping_add" => return #`u32wrapping_add;
    | "u32overflowing_add3" => return #`u32overflowing_add3;

    | "u32checked_sub" => return #`u32checked_sub;
    | "u32overflowing_sub" => return #`u32overflowing_sub;
    | "u32wrapping_sub" => return #`u32wrapping_sub;

    | "u32checked_mul" => return #`u32checked_mul;
    | "u32overflowing_mul" => return #`u32overflowing_mul;
    | "u32wrapping_mul" => return #`u32wrapping_mul;
    | "u32overflowing_madd" => return #`u32overflowing_madd;

    | "u32checked_div" => return #`u32checked_div;
    | "u32unchecked_div" => return #`u32unchecked_div;

    | "u32checked_mod" => return #`u32checked_mod;
    | "u32unchecked_mod" => return #`u32unchecked_mod;

    | "u32checked_divmod" => return #`u32checked_divmod;
    | "u32unchecked_divmod" => return #`u32unchecked_divmod; 

    | "u32checked_and" => return #`u32checked_and;
    | "u32checked_or" => return #`u32checked_or;
    | "u32checked_xor" => return #`u32checked_xor;
    | "u32checked_not" => return #`u32checked_not;

    | "u32checked_shl" => return #`u32checked_shl;
    | "u32unchecked_shl" => return #`u32unchecked_shl;

    | "u32checked_shr" => return #`u32checked_shr;
    | "u32unchecked_shr" => return #`u32unchecked_shr;

    | "u32checked_rotl" => return #`u32checked_rotl;
    | "u32unchecked_rotl" => return #`u32unchecked_rotl;

    | "u32checked_rotr" => return #`u32checked_rotr;
    | "u32unchecked_rotr" => return #`u32unchecked_rotr;
 
    | "u32checked_eq" => return #`u32checked_eq;
    | "u32checked_neq" => return #`u32checked_neq;

    | "u32checked_lt" => return #`u32checked_lt;
    | "u32unchecked_lt" => return #`u32unchecked_lt;
    | "u32checked_lte" => return #`u32checked_lte;
    | "u32unchecked_lte" => return #`u32unchecked_lte;
    | "u32checked_gt" => return #`u32checked_gt;
    | "u32unchecked_gt" => return #`u32unchecked_gt;
    | "u32checked_gte" => return #`u32checked_gte;
    | "u32unchecked_gte" => return #`u32unchecked_gte;

    | "u32checked_min" => return #`u32checked_min;
    | "u32unchecked_min" => return #`u32unchecked_min;
    | "u32checked_max" => return #`u32checked_max;
    | "u32unchecked_max" => return #`u32unchecked_max;

    | "drop" => return #`drop;
    | "dropw" => return #`dropw;
    | "padw" => return #`padw;
    | "dup" => return #`dup;
    | "dupw" => return #`dupw;
    | "swap" => return #`swap;

    | "cswap" => return #`cswap;
    | "cswapw" => return #`cswapw;

    | "sdepth" => return #`sdepth;
    | "caller" => return #`caller;

    | "adv_loadw" => return #`adv_loadw;
    | "adv_pipe" => return #`adv_pipe;

    | "mem_load" => return #`mem_load;
    | "mem_loadw" => return #`mem_loadw;

    | "mem_store" => return #`mem_store;
    | "mem_storew" => return #`mem_storew;
    | "mem_stream" => return #`mem_stream;

    | "rpperm" => return #`rpperm;
    | "rphash" => return #`rphash;
    | "mtree_get" => return #`mtree_get;
    | "mtree_set" => return #`mtree_set;
    | "mtree_cwm" => return #`mtree_cwm;

  | _ => fail$ "unrecognised opcode " + op;
  endmatch;
};

fun parse_im_op (fail:string->any) (op: string) : imode_t {
  match op with

    | "add" => return #`add;
    | "sub" => return #`sub;
    | "mul" => return #`mul;
    | "div" => return #`div;
    | "exp" => return #`exp;
    | "eq" => return #`eq;
    | "neq" => return #`neq;


    | "u32checked_add" => return #`u32checked_add;
    | "u32overflowing_add" => return #`u32overflowing_add;
    | "u32wrapping_add" => return #`u32wrapping_add;
    | "u32wrapping_add3" => return #`u32wrapping_add3;

    | "u32checked_sub" => return #`u32checked_sub;
    | "u32overflowing_sub" => return #`u32overflowing_sub;
    | "u32wrapping_sub" => return #`u32wrapping_sub;

    | "u32checked_mul" => return #`u32checked_mul;
    | "u32overflowing_mul" => return #`u32overflowing_mul;
    | "u32wrapping_mul" => return #`u32wrapping_mul;
    | "u32wrapping_madd" => return #`u32wrapping_madd;

    | "u32checked_div" => return #`u32checked_div;
    | "u32unchecked_div" => return #`u32unchecked_div;

    | "u32checked_mod" => return #`u32checked_mod;
    | "u32unchecked_mod" => return #`u32unchecked_mod;

    | "u32checked_divmod" => return #`u32checked_divmod;
    | "u32unchecked_divmod" => return #`u32unchecked_divmod;

    | "u32checked_shl" => return #`u32checked_shl;
    | "u32unchecked_shl" => return #`u32unchecked_shl;

    | "u32checked_shr" => return #`u32checked_shr;
    | "u32unchecked_shr" => return #`u32unchecked_shr;

    | "u32checked_rotl" => return #`u32checked_rotl;
    | "u32unchecked_rotl" => return #`u32unchecked_rotl;

    | "u32checked_rotr" => return #`u32checked_rotr;
    | "u32unchecked_rotr" => return #`u32unchecked_rotr;
 
    | "u32checked_eq" => return #`u32checked_eq;
    | "u32checked_neq" => return #`u32checked_neq;

    | "dup" => return #`dup;
    | "dupw" => return #`dupw;
    | "swap" => return #`swap;
    | "swapw" => return #`swapw;
    | "movup" => return #`movup;
    | "movupw" => return #`movupw;
    | "movdn" => return #`movdn;
    | "movdnw" => return #`movdnw;
    | "locaddr" => return #`locaddr;

    | "mem_load" => return #`mem_load;
    | "mem_loadw" => return #`mem_loadw;

    | "mem_store" => return #`mem_store;
    | "mem_storew" => return #`mem_storew;

    | "loc_load" => return #`loc_load;
    | "loc_loadw" => return #`loc_loadw;
    | "loc_store" => return #`loc_store;
    | "loc_storew" => return #`loc_storew;


  | _ => fail$ "unrecognised opcode " + op;
  endmatch;
};


fun oparse(fail:string->any) (x:token_t) : op_t {
  var subtoks = split (x,".");;
  match subtoks with
  | [op] => return parse_basic_op fail op :>> op_t;

  | "push"! tail =>
     var ints = unbox$ map (fun (s:string) => (parse_int_lit fail s).int) tail;
     if ints.len.int > 16 perform fail$ "push has " + ints.len.str + " operands, max 16";
     return `push ints :>> op_t;

  | [op,arg] => 
    var y = 
      if isdecintlit arg then (parse_dec_lit fail arg).int
      elif ishexintlit arg then (parse_hex_lit fail arg).int
      else fail$ "Integer required after " + op + "."
      endif
    ;
    return `im (parse_im_op fail op, y) :>> op_t;

  | _ => fail$ "Unrecognised opcode " + x;
  endmatch;
}

}
