class MidenOpcodes {

  // A field element is 64 bits, a machine word is 256 bits = 4 field elements
  // u32 is 32 bits = 4 bytes = 8 hex digits
  // field element is 16 hex digits
  // machine word is 64 hex digits
  //
  //  ordinary swaps and move things are MISCODED
  //  as 0 pop 0 push ... should really be 16,16
  //  similarly dup.n which is really n, n + 1
  //  and adv_push.$
  //  These will need special handing in the emulator


  //  OPCODE                cycles, pop, push
  //  codes with .$ at the end accept an integer literal

  var opcodes = 
    ("assert"                 ,1,1,0),
    ("assertz"                ,2,1,0),
    ("assert_eq"              ,2,2,0),

    ("add"                    ,1,2,1),
    ("add.$"                  ,2,1,1),
    ("sub"                    ,2,2,1),
    ("sub.$"                  ,2,1,1),
    ("mul"                    ,1,2,1),
    ("mul.$"                  ,2,1,1),
    ("div"                    ,2,2,1),
    ("div.$"                  ,2,1,1),
    ("neg"                    ,1,1,1),
    ("inv"                    ,1,1,1),
    ("pow2"                   ,16,1,1),
    ("exp"                    ,73,2,1),
    ("exp.$"                  ,73,1,1),
    ("not"                    ,1,1,1),
    ("and"                    ,1,2,1),
    ("or"                     ,1,2,1),
    ("xor"                    ,7,2,1),
    ("eq"                     ,1,2,1),
    ("eq.$"                   ,2,1,1),
    ("neq"                    ,1,2,1),
    ("neq.$"                  ,2,1,1),
    ("lt"                     ,17,2,1),
    ("lte"                    ,18,2,1),
    ("gt"                     ,18,2,1),
    ("gte"                    ,18,2,1),
    ("eqw"                    ,15,8,4),

    ("u32test"                 ,5,1,2),               
    ("u32testw"                ,23,4,5),
    ("u32assert"               ,3,1,1),
    ("u32assert.1"             ,3,1,1),
    ("u32assert.2"             ,1,2,2),
    ("u32assertw"              ,6,4,4),
    ("u32cast"                 ,2,1,1),
    ("u32split"                ,1,1,2),

    ("u32checked_add"          ,4,2,1),
    ("u32checked_add.$"        ,6,1,1),
    ("u32overflowing_add"      ,1,2,2),
    ("u32overflowing_add.$"    ,3,1,2),
    ("u32wrapping_add"         ,2,2,1),
    ("u32wrapping_add.$"       ,4,1,1),
    ("u32overflowing_add3"     ,1,3,2),
    ("u32wrapping_add3.$"      ,2,3,1),

    ("u32checked_sub"          ,4,2,1),
    ("u32checked_sub.$"        ,6,1,1),
    ("u32overflowing_sub"      ,1,2,2),
    ("u32overflowing_sub.$"    ,2,1,2),
    ("u32wrapping_sub"         ,2,2,1),
    ("u32wrapping_sub.$"       ,4,1,1),

    ("u32checked_mul"          ,4,2,1),
    ("u32checked_mul.$"        ,6,1,1),
    ("u32overflowing_mul"      ,1,2,2),
    ("u32overflowing_mul.$"    ,3,1,2),
    ("u32wrapping_mul"         ,2,2,1),
    ("u32wrapping_mul.$"       ,4,1,1),
    ("u32overflowing_madd"     ,1,3,2),
    ("u32wrapping_madd.$"      ,2,3,1),

    ("u32checked_div"          ,3,2,1),
    ("u32checked_div.$"        ,5,1,1),
    ("u32unchecked_div"        ,2,2,1),
    ("u32unchecked_div.$"      ,4,1,1),

    ("u32checked_mod"          ,4,2,1),
    ("u32checked_mod.$"        ,6,1,1),
    ("u32unchecked_mod"        ,3,2,1),
    ("u32unchecked_mod.$"      ,5,1,1),

    ("u32checked_divmod"       ,2,2,2),
    ("u32checked_divmod.$"     ,4,1,2),
    ("u32unchecked_divmod"     ,1,2,2), 
    ("u32unchecked_divmod.$"   ,3,1,2),

    ("u32checked_and"          ,1,2,1),
    ("u32checked_or"           ,6,2,1),
    ("u32checked_xor"          ,1,2,1),
    ("u32checked_not"          ,5,1,1),

    ("u32checked_shl"          ,47,2,1),
    ("u32checked_shl.$"        ,4,1,1),
    ("u32unchecked_shl"        ,40,2,1),
    ("u32unchecked_shl.$"      ,3,1,1),

    ("u32checked_shr"          ,47,2,1),
    ("u32checked_shr.$"        ,4,1,1),
    ("u32unchecked_shr"        ,47,2,1),
    ("u32unchecked_shr.$"      ,4,1,1),

    ("u32checked_rotl"         ,47,2,1),
    ("u32checked_rotl.$"       ,4,1,1),
    ("u32unchecked_rotl"       ,40,2,1),
    ("u32unchecked_rotl.$"     ,3,1,1),

    ("u32checked_rotr"         ,59,2,1),
    ("u32checked_rotr.$"       ,6,1,1),
    ("u32unchecked_rotr"       ,44,2,1),
    ("u32unchecked_rotr.$"     ,3,1,1),
 
    ("u32checked_eq"           ,2,2,1),
    ("u32checked_eq.$"         ,4,1,1),
    ("u32checked_neq"          ,3,2,1),
    ("u32checked_neq.$"        ,5,1,1),

    ("u32checked_lt"           ,6,2,1),
    ("u32unchecked_lt"         ,5,2,1),
    ("u32checked_lte"          ,8,2,1),
    ("u32unchecked_lte"        ,7,2,1),
    ("u32checked_gt"           ,7,2,1),
    ("u32unchecked_gt"         ,6,2,1),
    ("u32checked_gte"          ,7,2,1),
    ("u32unchecked_gte"        ,6,2,1),

    ("u32checked_min"          ,9,2,1),
    ("u32unchecked_min"        ,8,2,1),
    ("u32checked_max"          ,10,2,1),
    ("u32unchecked_max"        ,9,2,1),

    ("drop"                    ,1,1,0),
    ("dropw"                   ,4,4,0),
    ("padw"                    ,4,0,4),
    ("dup"                     ,1,0,1),
    ("dup.$"                   ,3,0,1),
    ("dupw"                    ,4,0,4),
    ("dupw.$"                  ,4,0,4),
    ("swap"                    ,6,0,0),
    ("swap.$"                  ,6,0,0),
    ("swapw.$"                 ,1,0,0),
    ("movup.$"                 ,4,0,0),
    ("movupw.$"                ,3,0,0),
    ("movdn.$"                 ,4,0,0),
    ("movdnw.$"                ,3,1,0),

    ("cswap"                   ,1,1,0),
    ("cswapw"                  ,1,1,0),

    ("sdepth"                  ,2,0,1),
    ("caller"                  ,1,0,1),
    ("locaddr.$"               ,2,0,1),

    ("adv_loadw"               ,1,0,4),
    ("adv_pipe"                ,2,13,13),

    ("mem_load"                ,1,1,1),
    ("mem_load.$"              ,2,0,1),
    ("mem_loadw"               ,1,5,4),
    ("mem_loadw.$"             ,2,4,4),

    ("mem_store"               ,2,2,0),
    ("mem_store.$"             ,4,1,0),
    ("mem_storew"              ,1,5,0),
    ("mem_storew.$"            ,3,4,0),
    ("mem_stream"              ,2,13,13),

    ("loc_load.$"              ,4,0,1),
    ("loc_loadw.$"             ,4,0,4),
    ("loc_store.$"             ,5,1,0),
    ("loc_storew.$"            ,4,4,4),

    ("rpperm"                  ,1,12,12),
    ("rphash"                  ,16,8,4),
    ("mtree_get"               ,9,6,4),
    ("mtree_set"               ,14,10,8),
    ("mtree_cwm"               ,12,10,12)
  ;

  // check for integer literals miden allows WITHOUT any bounds checks
  fun ishexintlit(x:string) => x in RE2 "\\d+";
  fun isdecintlit(x:string) => x in RE2 "0x[[:xdigit:]]+";
  fun isintlit(x:string) => x.ishexintlit or x.isdecintlit;

  // check for a miden name
  fun isname(x:string) => x in RE2 "\\w+"; 
  fun isqualifiedname(x:string) => x in RE2 "\\w+(::\\w+)*"; 

  fun isopcode(x:string) {
    for v in opcodes 
      if v.0 == x return true;
    return false;
  }

  fun isvalidpush (x:string) {
    return x in RE2 "push(\\.(\\d|0x[[:xdigit:]]+)){1,16}";
  }

  // cdrop consumes either 1 element or 2 depending on the TOS
  // cdropw consumes either 1 element or 5 depending on the TOS
  fun iscdrop(x:string) {
    return x in ("cdrop", "cdropw");
  }

  fun isctrl(x:string) {
    return x in ("if.true", "while.true", "else", "end", "begin");
  }

  fun isvalid1op (x:string) =>
    x in ("end","begin","else","cdrop","cdropw") or
    x.isopcode
  ; 

  fun isvalid2op (a:string, b:string) {
    match a,b with
    | "if", "true" => return true;
    | "while", "true" => return true;
    | "repeat", x => return x.isintlit;
    | "exec", x => return x.isqualifiedname;
    | "call", x => return x.isqualifiedname;
    | "syscall", x => return x.isqualifiedname;
    | op,arg =>
      return arg.isintlit and (op+".$").isopcode;
    endmatch;
  }

  fun isvalid3op (a:string, b:string,c:string) {
    match a,b,c with
    | "proc", name,nlocals => return name.isname and nlocals.isintlit;
    | _ => return false;
    endmatch;
  }

 
  fun isvalidopcode (tokens: list[string]) {
    // get rid of the deviant push opcode
    if (cat "" tokens).isvalidpush return true;

    // all other ops have 1,2,or 3 parts separated by "."
    match tokens with
    | ([op]) => return isvalid1op(op);
    | ([op,d,a]) =>
       if d == "." do
         return isvalid2op(op,a);
       else 
         return false;
       done
    | ([op,d1,a,d2,b]) =>
       if d1 == "." and d2 == "." do
         return isvalid3op(op,a,b);
       else 
         return false;
       done
    | _ => return false;
    endmatch;
  }
}
