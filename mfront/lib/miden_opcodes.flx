class MidenOpcodes {

  // A field element is 64 bits, a machine word is 256 bits = 4 field elements
  // u32 is 32 bits = 4 bytes = 8 hex digits
  // field element is 16 hex digits
  // machine word is 64 hex digits
  //
  //  ordinary swaps and move things are MISCODED
  //  as 0 pop 0 push ... should really be 16,16
  //  similarly dup.n which is really n, n + 1
  //  and adv_push.$
  //  These will need special handing in the emulator


  //  OPCODE                cycles, pop, push
  //  codes with .$ at the end accept an integer literal

  var opcodes = 
    ("assert"                 ,1,1,0),
    ("assertz"                ,2,1,0),
    ("assert_eq"              ,2,2,0),

    ("add"                    ,1,2,1),
    ("add.$"                  ,2,1,1),
    ("sub"                    ,2,2,1),
    ("sub.$"                  ,2,1,1),
    ("mul"                    ,1,2,1),
    ("mul.$"                  ,2,1,1),
    ("div"                    ,2,2,1),
    ("div.$"                  ,2,1,1),
    ("neg"                    ,1,1,1),
    ("inv"                    ,1,1,1),
    ("pow2"                   ,16,1,1),
    ("exp"                    ,73,2,1),
    ("exp.$"                  ,73,1,1),
    ("not"                    ,1,1,1),
    ("and"                    ,1,2,1),
    ("or"                     ,1,2,1),
    ("xor"                    ,7,2,1),
    ("eq"                     ,1,2,1),
    ("eq.$"                   ,2,1,1),
    ("neq"                    ,1,2,1),
    ("neq.$"                  ,2,1,1),
    ("lt"                     ,17,2,1),
    ("lte"                    ,18,2,1),
    ("gt"                     ,18,2,1),
    ("gte"                    ,18,2,1),
    ("eqw"                    ,15,8,4),

    ("u32test"                 ,5,1,2),               
    ("u32testw"                ,23,4,5),
    ("u32assert"               ,3,1,1),
    ("u32assert.1"             ,3,1,1),
    ("u32assert.2"             ,1,2,2),
    ("u32assertw"              ,6,4,4),
    ("u32cast"                 ,2,1,1),
    ("u32split"                ,1,1,2),

    ("u32checked_add"          ,4,2,1),
    ("u32checked_add.$"        ,6,1,1),
    ("u32overflowing_add"      ,1,2,2),
    ("u32overflowing_add.$"    ,3,1,2),
    ("u32wrapping_add"         ,2,2,1),
    ("u32wrapping_add.$"       ,4,1,1),
    ("u32overflowing_add3"     ,1,3,2),
    ("u32wrapping_add3.$"      ,2,3,1),

    ("u32checked_sub"          ,4,2,1),
    ("u32checked_sub.$"        ,6,1,1),
    ("u32overflowing_sub"      ,1,2,2),
    ("u32overflowing_sub.$"    ,2,1,2),
    ("u32wrapping_sub"         ,2,2,1),
    ("u32wrapping_sub.$"       ,4,1,1),

    ("u32checked_mul"          ,4,2,1),
    ("u32checked_mul.$"        ,6,1,1),
    ("u32overflowing_mul"      ,1,2,2),
    ("u32overflowing_mul.$"    ,3,1,2),
    ("u32wrapping_mul"         ,2,2,1),
    ("u32wrapping_mul.$"       ,4,1,1),
    ("u32overflowing_madd"     ,1,3,2),
    ("u32wrapping_madd.$"      ,2,3,1),

    ("u32checked_div"          ,3,2,1),
    ("u32checked_div.$"        ,5,1,1),
    ("u32unchecked_div"        ,2,2,1),
    ("u32unchecked_div.$"      ,4,1,1),

    ("u32checked_mod"          ,4,2,1),
    ("u32checked_mod.$"        ,6,1,1),
    ("u32unchecked_mod"        ,3,2,1),
    ("u32unchecked_mod.$"      ,5,1,1),

    ("u32checked_divmod"       ,2,2,2),
    ("u32checked_divmod.$"     ,4,1,2),
    ("u32unchecked_divmod"     ,1,2,2), 
    ("u32unchecked_divmod.$"   ,3,1,2),

    ("u32checked_and"          ,1,2,1),
    ("u32checked_or"           ,6,2,1),
    ("u32checked_xor"          ,1,2,1),
    ("u32checked_not"          ,5,1,1),

    ("u32checked_shl"          ,47,2,1),
    ("u32checked_shl.$"        ,4,1,1),
    ("u32unchecked_shl"        ,40,2,1),
    ("u32unchecked_shl.$"      ,3,1,1),

    ("u32checked_shr"          ,47,2,1),
    ("u32checked_shr.$"        ,4,1,1),
    ("u32unchecked_shr"        ,47,2,1),
    ("u32unchecked_shr.$"      ,4,1,1),

    ("u32checked_rotl"         ,47,2,1),
    ("u32checked_rotl.$"       ,4,1,1),
    ("u32unchecked_rotl"       ,40,2,1),
    ("u32unchecked_rotl.$"     ,3,1,1),

    ("u32checked_rotr"         ,59,2,1),
    ("u32checked_rotr.$"       ,6,1,1),
    ("u32unchecked_rotr"       ,44,2,1),
    ("u32unchecked_rotr.$"     ,3,1,1),
 
    ("u32checked_eq"           ,2,2,1),
    ("u32checked_eq.$"         ,4,1,1),
    ("u32checked_neq"          ,3,2,1),
    ("u32checked_neq.$"        ,5,1,1),

    ("u32checked_lt"           ,6,2,1),
    ("u32unchecked_lt"         ,5,2,1),
    ("u32checked_lte"          ,8,2,1),
    ("u32unchecked_lte"        ,7,2,1),
    ("u32checked_gt"           ,7,2,1),
    ("u32unchecked_gt"         ,6,2,1),
    ("u32checked_gte"          ,7,2,1),
    ("u32unchecked_gte"        ,6,2,1),

    ("u32checked_min"          ,9,2,1),
    ("u32unchecked_min"        ,8,2,1),
    ("u32checked_max"          ,10,2,1),
    ("u32unchecked_max"        ,9,2,1),

    ("drop"                    ,1,1,0),
    ("dropw"                   ,4,4,0),
    ("padw"                    ,4,0,4),
    ("dup"                     ,1,0,1),
    ("dup.$"                   ,3,0,1),
    ("dupw"                    ,4,0,4),
    ("dupw.$"                  ,4,0,4),
    ("swap"                    ,6,0,0),
    ("swap.$"                  ,6,0,0),
    ("swapw.$"                 ,1,0,0),
    ("movup.$"                 ,4,0,0),
    ("movupw.$"                ,3,0,0),
    ("movdn.$"                 ,4,0,0),
    ("movdnw.$"                ,3,1,0),

    ("cswap"                   ,1,1,0),
    ("cswapw"                  ,1,1,0),

    ("sdepth"                  ,2,0,1),
    ("caller"                  ,1,0,1),
    ("locaddr.$"               ,2,0,1),

    ("adv_loadw"               ,1,0,4),
    ("adv_pipe"                ,2,13,13),

    ("mem_load"                ,1,1,1),
    ("mem_load.$"              ,2,0,1),
    ("mem_loadw"               ,1,5,4),
    ("mem_loadw.$"             ,2,4,4),

    ("mem_store"               ,2,2,0),
    ("mem_store.$"             ,4,1,0),
    ("mem_storew"              ,1,5,0),
    ("mem_storew.$"            ,3,4,0),
    ("mem_stream"              ,2,13,13),

    ("loc_load.$"              ,4,0,1),
    ("loc_loadw.$"             ,4,0,4),
    ("loc_store.$"             ,5,1,0),
    ("loc_storew.$"            ,4,4,4),

    ("rpperm"                  ,1,12,12),
    ("rphash"                  ,16,8,4),
    ("mtree_get"               ,9,6,4),
    ("mtree_set"               ,14,10,8),
    ("mtree_cwm"               ,12,10,12)
  ;

  // check for integer literals miden allows WITHOUT any bounds checks
  fun ishexintlit(x:string) => x in RE2 "\\d+";
  fun isdecintlit(x:string) => x in RE2 "0x[[:xdigit:]]+";
  fun isintlit(x:string) => x.ishexintlit or x.isdecintlit;

  // check for a miden name
  fun isname(x:string) => x in RE2 "\\w+"; 
  fun isqualifiedname(x:string) => x in RE2 "\\w+(::\\w+)*"; 

  fun isopcode(x:string) {
    for v in opcodes 
      if v.0 == x return true;
    return false;
  }

  fun isvalidpush (x:string) {
    return x in RE2 "push(\\.(\\d|0x[[:xdigit:]]+)){1,16}";
  }

  // cdrop consumes either 1 element or 2 depending on the TOS
  // cdropw consumes either 1 element or 5 depending on the TOS
  fun iscdrop(x:string) {
    return x in ("cdrop", "cdropw");
  }

  fun isctrl(x:string) {
    return x in ("if.true", "while.true", "else", "end", "begin");
  }

  fun isvalid1op (x:string) =>
    x in ("end","begin","else","cdrop","cdropw") or
    x.isopcode
  ; 

  fun isvalid2op (a:string, b:string) {
    match a,b with
    | "if", "true" => return true;
    | "while", "true" => return true;
    | "repeat", x => return x.isintlit;
    | "exec", x => return x.isqualifiedname;
    | "call", x => return x.isqualifiedname;
    | "syscall", x => return x.isqualifiedname;
    | "proc", x => return x.isname;
    | op,arg =>
      return arg.isintlit and (op+".$").isopcode;
    endmatch;
  }

  fun isvalid3op (a:string, b:string,c:string) {
    match a,b,c with
    | "proc", name,nlocals => return name.isname and nlocals.isintlit;
    | _ => return false;
    endmatch;
  }

 
  fun isvalidopcode (tokens: list[string]) {
    // get rid of the deviant push opcode
    if (cat "" tokens).isvalidpush return true;

    // all other ops have 1,2,or 3 parts separated by "."
    match tokens with
    | ([op]) => return isvalid1op(op);
    | ([op,d,a]) =>
       if d == "." do
         return isvalid2op(op,a);
       else 
         return false;
       done
    | ([op,d1,a,d2,b]) =>
       if d1 == "." and d2 == "." do
         return isvalid3op(op,a,b);
       else 
         return false;
       done
    | _ => return false;
    endmatch;
  }

typedef fieldop_t = (
    | `assert
    | `assertz
    | `assert_eq

    | `add
    | `sub
    | `mul
    | `div
    | `neg
    | `inv
    | `pow2
    | `exp
    | `not
    | `and
    | `or
    | `xor
    | `eq
    | `neq
    | `lt
    | `lte
    | `gt
    | `gte
    | `eqw
);

typedef u32_test_t = (
    | `u32test
    | `u32testw
    | `u32assert
    | `u32assert_1
    | `u32assert_2
    | `u32assertw
    | `u32cast
    | `u32split
);

typedef u32_checked_t =  (
    // u32 * u32 -> u32
    | `u32checked_add
    | `u32checked_sub
    | `u32checked_mul
    | `u32checked_div
    | `u32checked_mod

    // u32 * u32 -> u32 * u32
    | `u32checked_divmod

    // u32 * u32 -> u32
    | `u32checked_min
    | `u32checked_max
);
typedef u32_unchecked_t = (
    // u32 * u32 -> u32
    | `u32unchecked_min
    | `u32unchecked_max
    | `u32unchecked_div
    | `u32unchecked_mod
);

typedef u32_wrapping_t = (
    | `u32wrapping_add
    | `u32wrapping_sub
    | `u32wrapping_mul
);

// u32 * y32 -> u32 * u32
typedef u32_overflowing_t = (
    | `u32overflowing_add
    | `u32overflowing_sub
    | `u32overflowing_mul
);

// u32 * u32 * u32 -> u32 * u32
typedef u32_threeop_t = (
    | `u32overflowing_add3
    | `u32overflowing_madd
);

typedef u32_bitop_t = (
    | `u32checked_and
    | `u32checked_or
    | `u32checked_xor
    | `u32checked_not

    | `u32checked_shl
    | `u32unchecked_shl

    | `u32checked_shr
    | `u32unchecked_shr

    | `u32checked_rotl
    | `u32unchecked_rotl

    | `u32checked_rotr
    | `u32unchecked_rotr
);

typedef u32_comparison_t = (
    | `u32checked_eq
    | `u32checked_neq

    | `u32checked_lt
    | `u32unchecked_lt
    | `u32checked_lte
    | `u32unchecked_lte
    | `u32checked_gt
    | `u32unchecked_gt
    | `u32checked_gte
    | `u32unchecked_gte
);

typedef u32_base_t = (
  | u32_comparison_t
  | u32_bitop_t
  | u32_threeop_t
  | u32_overflowing_t
  | u32_wrapping_t
  | u32_checked_t
  | u32_unchecked_t
  | u32_test_t
);

typedef stack_manip_t = (
    | `drop
    | `dropw
    | `padw
    | `dup
    | `dupw
    | `swap

    | `cswap
    | `cswapw

    | `sdepth
    | `caller

    | `adv_loadw
    | `adv_pipe

    | `mem_load
    | `mem_loadw

    | `mem_store
    | `mem_storew
    | `mem_stream


    | `rpperm
    | `rphash
    | `mtree_get
    | `mtree_set
    | `mtree_cwm
);

// ops with immediate mode argumemts
typedef imode_t =
(
    | `add
    | `sub
    | `mul
    | `div
    | `exp
    | `eq
    | `neq


    | `u32checked_add
    | `u32overflowing_add
    | `u32wrapping_add
    | `u32wrapping_add3

    | `u32checked_sub
    | `u32overflowing_sub
    | `u32wrapping_sub

    | `u32checked_mul
    | `u32overflowing_mul
    | `u32wrapping_mul
    | `u32wrapping_madd

    | `u32checked_div
    | `u32unchecked_div

    | `u32checked_mod
    | `u32unchecked_mod

    | `u32checked_divmod
    | `u32unchecked_divmod

    | `u32checked_shl
    | `u32unchecked_shl

    | `u32checked_shr
    | `u32unchecked_shr

    | `u32checked_rotl
    | `u32unchecked_rotl

    | `u32checked_rotr
    | `u32unchecked_rotr
 
    | `u32checked_eq
    | `u32checked_neq

    | `dup
    | `dupw
    | `swap
    | `swapw
    | `movup
    | `movupw
    | `movdn
    | `movdnw
    | `locaddr

    | `mem_load
    | `mem_loadw

    | `mem_store
    | `mem_storew

    | `loc_load
    | `loc_loadw
    | `loc_store
    | `loc_storew
);

typedef imop_t = (
  | `immediate of imode_t * int 
);

}
